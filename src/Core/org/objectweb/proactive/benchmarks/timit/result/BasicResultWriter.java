/*
 * ################################################################
 *
 * ProActive: The Java(TM) library for Parallel, Distributed,
 *            Concurrent computing with Security and Mobility
 *
 * Copyright (C) 1997-2007 INRIA/University of Nice-Sophia Antipolis
 * Contact: proactive@objectweb.org
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
 * USA
 *
 *  Initial developer(s):               The ProActive Team
 *                        http://www.inria.fr/oasis/ProActive/contacts.html
 *  Contributor(s):
 *
 * ################################################################
 */
package org.objectweb.proactive.benchmarks.timit.result;

import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.Iterator;
import java.util.List;

import org.jdom.Attribute;
import org.jdom.Document;
import org.jdom.Element;
import org.objectweb.proactive.ProActive;
import org.objectweb.proactive.benchmarks.timit.TimIt;
import org.objectweb.proactive.benchmarks.timit.util.XMLHelper;
import org.objectweb.proactive.benchmarks.timit.util.basic.BasicTimer;
import org.objectweb.proactive.benchmarks.timit.util.basic.ResultBag;


/**
 * This class generate final result file from data generated by basic timers.
 * Generated file will be an XML file.
 *
 * @author Brian Amedro, Vladimir Bodnartchouk
 */
public class BasicResultWriter {
    public static final DecimalFormat df = new DecimalFormat("###.###",
            new DecimalFormatSymbols(java.util.Locale.US));

    /** The xml document */
    private Document document;

    /** The root xml element */
    private Element eTimit;

    /** The name of the output file */
    private String filename;

    /**
     * Creates an instance of this class with a given filename.
     * @param filename The name of the xml file
     */
    public BasicResultWriter(String filename) {
        this.eTimit = new Element("timit");
        this.document = new Document(this.eTimit);
        this.filename = filename;
    }

    /**
     * Use this method to add timers results to a single file.
     * @param bag A bag of timer results
     */
    public void addTimersElement(ResultBag bag) {
        if (bag == null) {
            return;
        }

        // Create the ao element
        Element aoElement = new Element("ao");
        this.fillTimersResults(aoElement, bag);
        // Attach the ao element as a child to the timit element
        this.eTimit.addContent(aoElement);
    }

    /**
     * Use this method to add timers results to a single file.
     * @param bag A bag of timer results
     */
    public void addGlobalInformationElement(String globalInformation) {
        if (globalInformation == null) {
            return;
        }

        // Create the globalInformation element
        Element globalInformationElement = new Element("globalInformation");
        globalInformationElement.setAttribute(new Attribute("value",
                globalInformation));
        // Attach the globalInformationElement element as a child to the timit element
        this.eTimit.addContent(globalInformationElement);
    }

    /**
     * This method is used to fill a specified element with timers results.
     * @param rootElement The root element that will be filled
     * @param bag A bag of timer results
     */
    private void fillTimersResults(final Element rootElement,
        final ResultBag bag) {
        String className = bag.getClassName();
        String uniqueID = bag.getUniqueID();
        List<BasicTimer> timersList = bag.getTimersList();
        String otherInformation = bag.getOtherInformation();
        // Set the classname value
        rootElement.setAttribute(new Attribute("className", className));
        // Set the uniqueID value
        rootElement.setAttribute(new Attribute("uniqueID", uniqueID));
        // Set the otherInformation value as an attribute value
        rootElement.setAttribute(new Attribute("otherInformation",
                otherInformation));
        // Set the proActiveVersion values as an attribute value
        rootElement.setAttribute(new Attribute("proActiveVersion",
                ProActive.getProActiveVersion()));
        // Create the timers element
        Element timersElement = new Element("timers");
        rootElement.addContent(timersElement);

        // Finding and adding all roots
        for (int i = 0; i < timersList.size(); i++) {
            // If the current is the root add it to the tree
            BasicTimer currentTimer = timersList.get(i);
            if (currentTimer.getParent() == null) {
                timersElement.addContent(createTimerElement(currentTimer));
                timersList.remove(i);
                i--;
            }
        }

        // Build the hierarchical tree
        for (int i = 0; i < timersList.size(); i++) {
            // If the current is the root add it to the tree
            BasicTimer currentTimer = timersList.get(i);
            int indexOfParent = timersList.indexOf(currentTimer.getParent());

            // If the parent is not in the list
            if (indexOfParent == -1) {
                // Then the parent should be in the tree and we can try to add
                // the current to the tree
                if (addTimerToItsParentElement(currentTimer, timersElement) == false) {
                    throw new RuntimeException("The timer " +
                        currentTimer.getName() +
                        " has no parent in the tree and no parent in the list.");
                } else {
                    // Else remove the current from the list
                    timersList.remove(i);
                    i--;
                }

                // If the parent is in the list
            } else {
                // Then try to add the parent to the tree
                if (addTimerToItsParentElement(currentTimer.getParent(),
                            timersElement)) {
                    // Remove the current.parent from the list
                    timersList.remove(indexOfParent);
                    i--;
                }
            }
        }
    }

    /**
     * Finds the parent of the timer then creates the element and
     * attaches it to the tree.
     * @param timerToAdd The timer to add in the xml tree
     * @param rootElement The root element
     * @return true if the parent was found and timer attached else return false
     */
    private boolean addTimerToItsParentElement(BasicTimer timerToAdd,
        Element rootElement) {
        // If the current element is the parent of the timerToAdd then add it
        Iterator<Element> it = rootElement.getDescendants();
        while (it.hasNext()) {
            Element ee = it.next();
            if (timerToAdd.getParent().getName()
                              .equals(ee.getAttributeValue("name"))) {
                ee.addContent(createTimerElement(timerToAdd));
                return true;
            }
        }
        return false;
    }

    /**
     * Creates a an element timer from an instance of a timer
     * @param currentTimer The timer to create an element of.
     * @return The created element.
     */
    private static final Element createTimerElement(
        final BasicTimer currentTimer) {
        final Element newTimerElement = new Element("timer");
        // Set the name as an attribute
        newTimerElement.setAttribute(new Attribute("name",
                currentTimer.getName()));
        // Set the totalTime in millis of the timer as an attribute
        newTimerElement.setAttribute(new Attribute("totalTimeInMillis",
                "" + (((double) currentTimer.getTotalTime()) / 1000000d)));
        // Set the number of startStopCoupleCount value
        newTimerElement.setAttribute(new Attribute("startStopCoupleCount",
                "" + currentTimer.getStartStopCoupleCount()));
        return newTimerElement;
    }

    /**
     * Writes this document to a file
     */
    public void writeToFile() {
        XMLHelper.writeFile(this.document, this.filename);
    }

    /**
     * Prints the XML tree.
     */
    public void printMe() {
        XMLHelper.printOut(this.document);
    }

    /**
     * Checks the best format for a time value.
     * @param timeInNanos The initial time is taken in nanoseconds
     * @return The formatted representation of the time value.
     */
    private static final String checkBestFormat(double t) {
        double timeInNanos = t;
        String format = null;
        double result = 0;

        // Check if nanoseconds is ok
        if ((timeInNanos / 1000000) < 1) {
            format = "nanos";
            result = timeInNanos;
        } else {
            // Set to milliseconds
            double timeInMillis = timeInNanos / 1000000;

            // Check if milliseconds is ok
            if ((timeInMillis / 1000) < 1) {
                format = "millis";
                result = timeInMillis;
            } else {
                double timeInSeconds = timeInMillis / 1000;

                // Check if milliseconds is ok
                if ((timeInSeconds / 60) < 1) {
                    format = "secs";
                    result = timeInSeconds;
                } else {
                    // return time in minutes
                    format = "mins";
                    result = timeInSeconds / 60;
                }
            }
        }
        return TimIt.df.format(result) + " " + format;
    }
}