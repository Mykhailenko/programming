/*
 * ################################################################
 *
 * ProActive: The Java(TM) library for Parallel, Distributed,
 *            Concurrent computing with Security and Mobility
 *
 * Copyright (C) 1997-2007 INRIA/University of Nice-Sophia Antipolis
 * Contact: proactive@objectweb.org
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
 * USA
 *
 *  Initial developer(s):               The ProActive Team
 *                        http://www.inria.fr/oasis/ProActive/contacts.html
 *  Contributor(s):
 *
 * ################################################################
 */
package org.objectweb.proactive.benchmarks.timit.result;

import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.Iterator;
import java.util.List;

import org.jdom.Attribute;
import org.jdom.Document;
import org.jdom.Element;
import org.objectweb.proactive.ProActive;
import org.objectweb.proactive.benchmarks.timit.TimIt;
import org.objectweb.proactive.benchmarks.timit.util.XMLHelper;
import org.objectweb.proactive.benchmarks.timit.util.basic.BasicTimer;
import org.objectweb.proactive.benchmarks.timit.util.basic.ResultBag;


/**
 * This class generate final result file from data generated by basic timers.
 * Generated file will be an XML file.
 *
 * @author Brian Amedro, Vladimir Bodnartchouk
 */
public class BasicResultWriter {
    public static final DecimalFormat df = new DecimalFormat("###.###",
            new DecimalFormatSymbols(java.util.Locale.US));
    private Document document;
    private Element eTimit;
    private String filename;

    /**
     * Creates an instance of this class with a given filename.
     * @param filename The name of the xml file
     */
    public BasicResultWriter(String filename) {
        this.eTimit = new Element("timit");
        this.document = new Document(this.eTimit);
        this.filename = filename;
    }

    /**
     * Use this method to add timers results to a single file.
     * @param bag A bag of timer results
     */
    public void addTimersElement(ResultBag bag) {
        if (bag == null) {
            return;
        }

        // Create the ao element
        Element aoElement = new Element("ao");
        this.fillTimersResults(aoElement, bag);
        // Attach the ao element as a child to the timit element
        this.eTimit.addContent(aoElement);
    }

    /**
     * This method is used to fill a specified element with timers results.
     * @param rootElement The root element that will be filled
     * @param bag A bag of timer results
     */
    private void fillTimersResults(final Element rootElement,
        final ResultBag bag) {
        String className = bag.getClassName();
        String uniqueID = bag.getUniqueID();
        List<BasicTimer> timersList = bag.getTimersList();
        String otherInformation = bag.getOtherInformation();
        // Set the classname value
        rootElement.setAttribute(new Attribute("className", className));
        // Set the uniqueID value
        rootElement.setAttribute(new Attribute("uniqueID", uniqueID));
        // Set the otherInformation value as an attribute value
        rootElement.setAttribute(new Attribute("otherInformation",
                otherInformation));
        // Set the proActiveVersion values as an attribute value
        rootElement.setAttribute(new Attribute("proActiveVersion",
                ProActive.getProActiveVersion()));
        // Create the timers element
        Element timersElement = new Element("timers");
        rootElement.addContent(timersElement);

        // Iterate through the list of timers
        Iterator<BasicTimer> timersListIterator = timersList.iterator();
        Iterator descendantsIterator = null;
        Element parentElement = null;
        BasicTimer currentTimer = null;

        while (timersListIterator.hasNext()) {
            currentTimer = timersListIterator.next();
            if (currentTimer.getParent() == null) {
                timersElement.addContent(createTimerElement(currentTimer));
            } else {
                // Find the timer with the name of the parent and attach its child
                descendantsIterator = timersElement.getDescendants();
                while (descendantsIterator.hasNext()) {
                    parentElement = (Element) descendantsIterator.next();
                    // Match the parent
                    if (parentElement.getAttributeValue("name")
                                         .equals(currentTimer.getParent()
                                                                 .getName())) {
                        parentElement.addContent(createTimerElement(
                                currentTimer));
                        break;
                    }
                }
            }
        }
    }

    /**
     * Creates a an element timer from an instance of a timer
     * @param currentTimer The timer to create an element of.
     * @return The created element.
     */
    private static final Element createTimerElement(
        final BasicTimer currentTimer) {
        final Element newTimerElement = new Element("timer");
        // Set the name as an attribute
        newTimerElement.setAttribute(new Attribute("name",
                currentTimer.getName()));
        // Set the user readable totalTime of the timer as an attribute
        // newTimerElement.setAttribute(new Attribute("totalTime", SimpleResultWriter.checkBestFormat(currentTimer.getTotalTime())));
        // Set the totalTime in millis of the timer as an attribute
        newTimerElement.setAttribute(new Attribute("totalTimeInMillis",
                "" + (((double) currentTimer.getTotalTime()) / 1000000d)));
        // Set the number of startStopCoupleCount value
        newTimerElement.setAttribute(new Attribute("startStopCoupleCount",
                "" + currentTimer.getStartStopCoupleCount()));
        return newTimerElement;
    }

    /**
     * Writes this document to a file
     */
    public void writeToFile() {
        XMLHelper.writeFile(this.document, this.filename);
    }

    /**
     * Prints the XML tree.
     */
    public void printMe() {
        XMLHelper.printOut(this.document);
    }

    /**
     * Checks the best format for a time value.
     * @param timeInNanos The initial time is taken in nanoseconds
     * @return The formatted representation of the time value.
     */
    private static final String checkBestFormat(double t) {
        double timeInNanos = t;
        String format = null;
        double result = 0;

        // Check if nanoseconds is ok
        if ((timeInNanos / 1000000) < 1) {
            format = "nanos";
            result = timeInNanos;
        } else {
            // Set to milliseconds
            double timeInMillis = timeInNanos / 1000000;

            // Check if milliseconds is ok
            if ((timeInMillis / 1000) < 1) {
                format = "millis";
                result = timeInMillis;
            } else {
                double timeInSeconds = timeInMillis / 1000;

                // Check if milliseconds is ok
                if ((timeInSeconds / 60) < 1) {
                    format = "secs";
                    result = timeInSeconds;
                } else {
                    // return time in minutes
                    format = "mins";
                    result = timeInSeconds / 60;
                }
            }
        }
        return TimIt.df.format(result) + " " + format;
    }
}
