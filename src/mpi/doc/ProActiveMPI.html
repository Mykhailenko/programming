<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=windows-1252">
  <meta name="Generator" content="Microsoft Word 97">
  <title>PAPI: the ProActive Gateway to MPI World</title>
</head>
<body link="#0000ff">
<b><font color="#000080" face="Arial" size="6">ProActiveMPI</font></b><small><font
 color="#000080" face="Arial" size="6"><small><small><small><small><br>
040604-040812-00</small></small></small></small></font></small><font
 face="Arial" size="1">
</font><b><font face="Arial" size="2"></font></b><br>
<hr style="width: 100%; height: 2px;"><font face="Arial" size="2"><i>
<p>Hereby, we describe the ProActive to MPI Interface, namely
ProActiveMPI, that is designed to interface MPI applications with
ProActive applications. ProActiveMPI is designed to provide the user
with a solution to run any standard MPI application from the ProActive
application side and two simple ways to perform communications between
MPI side and Java side.</p>
</i>
</font>
<p><font face="Arial" size="2">&nbsp;</font></p>
<b><font color="#000080" face="Arial" size="2">
<p>INTRODUCTION</p>
</font></b><font face="Arial" size="2">
<p>The ProActiveMPI Interface is designed to interface MPI applications
with ProActive. Applications aimed by this library are specifically
applications of high performance computing. Numerical methodologies are
used to be paralleled using MPI. Digital simulations usually exploit a
local resource of calculation, which consists of a farm of PC including
a few tens of processors. A new objective is to use grid architecture
in order to address scalability purposes and thus, to be able to deploy
applications dimensioning on several hundreds of processors distributed
on several geographical sites. </p>
<p>ProActiveMPI is expected to support the development of ProActive
native software components (native components are components that are
embodying MPI legacy code) in order to allow the deployment of
applications of intensive calculation on a computing grid. For
instance, the results of this work could allow an autonomous
development, on the one hand, of software of digital simulation and, on
the other hand, of modules of visualisation, with <i>in fine</i> the
coupling of both by ProActive.</p>
<p>However, this work could more largely interest the MPI community of
programmers.</p>
<p>&nbsp;</p>
</font><b><font color="#000080" face="Arial" size="2">
<p>THE PROACTIVEMPI INTERFACE</p>
</font></b><font face="Arial" size="2">
<p>ProActiveMPI is an API designed to provide the user with:</p>
<ul>
  <li>A solution to run any standard MPI application from the ProActive
application side and get the results as the MPI application allows it;</li>
  <li>Two simple ways to perform communications between MPI side and
Java side.</li>
</ul>
<p>It is designed to reduce to the minimum the changes needed to use
any MPI application with a Java one, especially communication paradigms
remain the same in each specific world (Java or MPI).</p>
<p>Moreover, this API is the minimal stuff to support the
implementation of ProActive native software components.</p>
</font><b><font color="#000080" face="Arial" size="2">
<p>&nbsp;</p>
<p>Implementation</p>
</font></b><font face="Arial" size="2">
</font>
<p><font face="Arial" size="2">ProActiveMPI is implemented on top of
the Java Native Interface (JNI) and MPI functions.</font></p>
<p><font face="Arial" size="2">JNI is used to dynamically load and run
the MPI application.</font></p>
<p><font face="Arial" size="2">It also provides a way to allow
communications between the Java side and the MPI side. Actually, the
root node of the MPI application is loaded into the memory space of the
JVM through the use of JNI. In this way, the Java application and the
root node code of the MPI application are able to exchange data
information.</font></p>
<p><font face="Arial" size="2">MPI functions are used to openly pass on
data inside the MPI world.</font></p>
<p><font face="Arial" size="2">The MPI application is dynamically
loaded by the Java side by the means of the </font><font face="Arial"
 size="1">System.loadLibrary()</font><font face="Arial" size="2">
function as a standard shared library (on Unix operating systems the
shared library is a </font><font face="Arial" size="1">.so</font><font
 face="Arial" size="2"> file whilst on Windows operating systems it is
a dynamic link library (DLL) </font><font face="Arial" size="1">.dll</font><font
 face="Arial" size="2"> file):</font></p>
<font face="Arial" size="1">
<p>class MyClass</p>
<p>{</p>
<p> static</p>
<p> {</p>
<p> System.loadLibrary("mpicode");</p>
<p> }</p>
<p> </p>
<p> public static void main( String[] args )</p>
<p> {</p>
<p> // …</p>
<p> }</p>
<p>}</p>
</font><font face="Arial" size="2">
<p>&nbsp;</p>
</font><b><font color="#000080" face="Arial" size="2">
<p>Design</p>
</font></b><font face="Arial" size="2">
</font>
<p><font face="Arial" size="2">ProActiveMPI design was thought in a way
very little changes have to be made to the MPI side in order to use it
as part of a Java application. For this reason, and from the Java point
of view, the MPI application is considered as an autonomous application
with which communicate. </font></p>
<p><font face="Arial" size="2">Thus, it is up to the MPI code to deploy
itself as in standard case of running. The Java side is just
responsible to load the code for the root node inside its own memory
space and to call the ProActiveMPI function written to start the MPI
application (cf. the User interface section).</font></p>
<p><font face="Arial" size="2">To this point, communications between
both sides of the application can start:</font></p>
<ul>
  <li><font face="Arial" size="2">Using the dedicated ProActiveMPI
functions in the case standard communications are not existing;</font></li>
  <li><font face="Arial" size="2">Using standard communication
functions in other cases.</font></li>
</ul>
<p><font face="Arial" size="2">As for the MPI part of the whole
application, one must notice that only the root node is allowed to pass
on data to and from the Java side. It is the reason why any
communication to or from the Java side must be relayed by the root
node. </font></p>
<p><font face="Arial" size="2">From the MPI point of view, the Java
application is a programme that can be access onto the root node using
the specific communication tag: </font><font face="Arial" size="1">MPI_C_Interface_Tag</font><font
 face="Arial" size="2">.</font></p>
<p><font face="Arial" size="2">&nbsp;</font></p>
<b><font color="#000080" face="Arial" size="2">
<p><a name="sec_USERINTERFACE">User interface</a></p>
</font></b>
<font face="Arial" size="2">
<p>The API includes functions to run and end up an MPI application and
functions to communicate from and to any side of the whole Java/MPI
application.</p>
<p>The MPI set-up functions are:</p>
</font><font face="Arial" size="1">
<p>ProActiveMPI.loadMPI()</p>
<p>ProActiveMPI.startMPI()</p>
<p>ProActiveMPI.endMPI() </p>
<p>ProActiveMPI.initMPI()</p>
</font><font face="Arial" size="2">
<p>The communication functions are for the Java side:</p>
</font><font face="Arial" size="1">
<p>ProActiveMPI.sendToMPI()</p>
<p>ProActiveMPI.RecvFromMPI()</p>
</font><font face="Arial" size="2">
<p>They are for the MPI side:</p>
</font><font face="Arial" size="1">
<p>MPI_C_Interface_callMPI()</p>
</font><font face="Arial" size="2">
<p>In this way, the MPI user can easily continue to use his own
communication paradigm (message passing communications) to exchange
data information with the Java world, which is mainly based on a remote
procedure call communication paradigm.</p>
</font><font face="Arial" size="1"></font>
<p><font face="Arial" size="1">ProActiveMPI.loadMPI() </font><font
 face="Arial" size="2">must be used on the Java side as the first PAPI
call and before any communication to or from the MPI side. This
function set up the working environment, turning communications between
the Java side and the MPI side on an asynchronous mode (as the
ProActive documentation calls blocking communications), and
initializing MPI.</font></p>
<p><font face="Arial" size="2">If the MPI initialization fail, the user
is allowed to run the MPI initialization itself by calling the </font><font
 face="Arial" size="1">PAPI.init()</font><font face="Arial" size="2">
method. Calling this latter method must be done only in a failure case.
The user must specify the MPI application name as the parameter of the </font><font
 face="Arial" size="1">ProActiveMPI.loadMPI() </font><font face="Arial"
 size="2">method.</font></p>
<p><font face="Arial" size="2">The user calls the </font><font
 face="Arial" size="1">ProActiveMPI.startMPI() </font><font
 face="Arial" size="2">method in order to run his/her application on
the MPI side. In this way, the </font><font face="Arial" size="1">ProActiveMPI.startMPI()
</font><font face="Arial" size="2">C function must embodying all user
calls and data settings to run correctly the user MPI application. In
this function, the call to </font><font face="Arial" size="1">ProActiveMPI.initMPI().
</font><font face="Arial" size="2">Is not allowed as it has already
occure automatically at the set-up time.</font></p>
<p><font face="Arial" size="2">The MPI user should implement this
function instead of the standard C </font><font face="Arial" size="1">main</font><font
 face="Arial" size="2"> function to install his MPI application. It is
a need to change his MPI application, but it is not common that the </font><font
 face="Arial" size="1">main</font><font face="Arial" size="2"> function
directly implements this call. In this way, the only change is to turn
the name of the user function into the dedicated one, that is to say: </font><font
 face="Arial" size="1">MPI_C_Interface_startMPI</font><font face="Arial"
 size="2">.</font></p>
<p><font face="Arial" size="2">But this could be interesting to
maintain into the same C code two versions of the MPI application: a
standalone one and a Java interaction one, switching between them using
the specific definition of </font><font face="Arial" size="1">ProActiveMPI_java</font><font
 face="Arial" size="2">:</font></p>
<p><font face="Arial" size="2"> </font><font face="Arial" size="1">#ifdef
ProActiveMPI_java</font></p>
<p><font face="Arial" size="1"> /* Java running mode */</font></p>
<p><font face="Arial" size="1"> #else</font></p>
<p><font face="Arial" size="1"> /* Standalone running mode */</font></p>
<p><font face="Arial" size="1"> #endif</font></p>
<font face="Arial" size="2">
</font><font face="Arial" size="1"></font>
<p><font face="Arial" size="1">ProActiveMPI.endMPI() </font><font
 face="Arial" size="2">is an optional call from the Java side. In the
case this call is not performed from the Java side, it must be done
from the MPI side in order to terminate the MPI application properly.</font></p>
<p><font face="Arial" size="2">From the MPI side, communications to or
from the Java side are performed through the standard MPI communication
functions (</font><font face="Arial" size="1">MPI_Send()</font><font
 face="Arial" size="2"> and </font><font face="Arial" size="1">MPI_Recv()</font><font
 face="Arial" size="2">). The user only specifies a communication to or
from the root node (#0) and uses the specific tag: </font><font
 face="Arial" size="1">MPI_C_Interface_Tag</font><font face="Arial"
 size="2">.</font></p>
<p><font face="Arial" size="2">From the Java side, communications are
performed using the MPI mimetic functions called </font><font
 face="Arial" size="1">PAPI.send()</font><font face="Arial" size="2">
and </font><font face="Arial" size="1">ProActiveMPI.recvFromMPI().</font></p>
<font face="Arial" size="2"></font>
<p><font face="Arial" size="2">They are the message passing
communication set of ProActiveMPI.</font></p>
<p><font face="Arial" size="2">The remote procedure call communication
set of ProActiveMPI is implemented by the </font><font face="Arial"
 size="1">MPI_C_Interface_callMPI() </font><font face="Arial" size="2">function,
only accessible from the MPI side. Remote procedure call from Java to
MPI is not allowed because of meaningless.</font></p>
<p><font face="Arial" size="2">The MPI side can perform a </font><font
 face="Arial" size="1">ProActiveMPI.callMPI() </font><font face="Arial"
 size="2">in order to call any object method on the Java side. The
result of this call is passed back to the caller as the standard C
return call. The MPI user should notice that to deal with this result
he must use the functions provide by the JNI in order to properly
manage data information returned. No specific API is provided by
ProActiveMPI to do so.</font></p>
<p><font face="Arial" size="2">The current user interface function
prototypes are:</font></p>
<font face="Arial" size="2"><i>
<p>On the Java side :</p>
</i>
</font><font face="Arial" size="1">
<p>void startMPI();</p>
<p>int initMPI();</p>
<p>void endMPI();</p>
<p>void sendToMPI( byte text[], int length, int receiver );</p>
<p>void recvFromMPI( byte text[], int length, int sender, int status );</p>
<p>ProActiveMPI loadMPI( String mpi_application_name );</p>
</font><i><font face="Arial" size="2">
<p>On the MPI side :</p>
</font></i>
<font face="Arial" size="1"></font>
<p><font face="Arial" size="1">Jobject MPI_C_Interface_callMPI( char *
method_classname, char * method_name, char * method_signature, ... );</font></p>
<p><font face="Arial" size="1">CATCH_ERROR(
function_in_which_to_catch_error ); (</font><font face="Arial" size="2">This
is a special purpose function addressing error handling on the MPI side</font><font
 face="Arial" size="1">)</font></p>
<font face="Arial" size="2">
<p>&nbsp;</p>
</font><b><font color="#000080" face="Arial" size="2">
<p>CONCLUSION</p>
</font></b><font face="Arial" size="2">
<p>The ProActiveMPI Interface provide the user with a simple and
efficient way to allow communication between Java applications and MPI
native applications.</p>
<p>Its implementation on top of JNI allows both message passing and
remote procedure call communication paradigms to be use according to
the user convenience.</p>
<p>Message passing communications are designed to reduce the amount of
changes needed on the MPI side of the definite whole application.</p>
<p><br>
&nbsp;</p>
</font>
<hr style="width: 100%; height: 2px;">
<div style="text-align: right;"><font face="Arial" size="2">
<p>Copyright June 2004 INRIA All Rights Reserved.</p>
</font></div>
<font face="Arial" size="2">
<p> </p>
</font>
</body>
</html>
